<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="../assets/css/xua-documentation.css" rel="stylesheet" type="text/css" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
        }
      });
    </script>

    <title>Units; - XUA Documentation</title>
</head>

<body>

    <div id="page">

        <div id="header">
            <div class='booktitleinheader'><a href='../index.html'>XUA Documentation</a></div>
            <ul id='menu'>
                <li class='menu-item'><a href='../docs/index.html'>Table of Contents</a></li>
                <li class='menu-item'><a href='../docs/CheatSheet.html'>Cheat Sheet</a></li>
                <li class='menu-item'><a href='../docs/Architecture.html'>Architecture</a></li>
            </ul>
        </div>

        <div id="main">

            <h1 class="libtitle">
                Units;
                <span class="subtitle">The Fundamentals</span>
            </h1>

            <div class = 'comment'><a href='#Introduction'><h1 class='h1' id='Introduction'> Introduction</h1></a>
In this chapter, we try to focus on concepts and theories, reading this chapter helps the reader understand the concepts and fundamentals but to turn these theories into practice, one must read the main chapter of each section which is more practical. Not all of units are needed to be defined by the programmer and most of them are generated by XUA. There are only a few units that require practical understanding, and there is a main chapter for each.</div><div class = 'comment'><a href='#XUA_Server'><h1 class='h1' id='XUA_Server'> XUA Server</h1></a>
XUA generates three projects. XUA Server, Marshal Library, and Documentations. Among these projects, the server is the most important
one which contains all the units that serve logics to the whole project. The role of Server is to be an interface between user and
database which reads and modifies data, in this manner the server must check the permissions for read and write and serve proper
access to data for all users.</div><div class = 'comment'><a href='#Universal_Resources_Pool'><h2 class='h2' id='Universal_Resources_Pool'> Universal Resources Pool</h2></a>
A XUA Server contains a pool of resources that are available for use. These resources can be available universally, i.e., foreign
parties can use resources, and internally, i.e., available for internal resources and units. The idea is similar to private and
public features of a class, but a public feature is only accessible from other codes on the same project, while a universal resource
is accessible from other projects, even on other machines other than where server project is stored. XUA resources are divided to <a href='#Resource<em>Files'>Files</a>, <a href='#PHP</em>Service<em>Classes'>Services</a>, <a href='#Super</em>Types'>Supers</a>, <a href='#Entities'>Entities</a>, and <a href='#Methods'>Methods</a>.</div><div class = 'comment'><a href='#Super_Types'><h3 class='h3' id='Super_Types'> Super Types</h3></a>
<a href='Supers.html'>(main chapter)</a></div><div class = 'comment'>Super Types or simply Supers are actually parametric types.</div><div class = 'comment'>Let's talk about types first. One can think of a type as a set, for example the type <code>Integer</code> is actually the set $\mathbb{Z} = \{0, 1, -1, 2, -2, \dots \}$ and when we say that $42$ is of type <code>Integer</code>, this means that $42 \in \mathbb{Z}$, which is written $42 : \mathbb{Z}$ in XUA syntax. But there are some features that types usually have which sets don't. In XUA's definition of type, types have a characteristic function which defines the set, and also a marshal function and an unmarshal function that prepare the values for transmitting or storing. There is also another property for types, called <code>DatabaseType</code> which tells the database how to store a value of this type. So a type is actually a 4-tuple $T = (P, M, U, D)$ where predicate $P$ is the characteristic function, $M$ is the marshal function, $U$ is the unmarshal function, and $D$ is a string that defines the database type.</div><div class = 'comment'>As an example (that is not quite practical and efficient) let $T$ be the type of integers. We know $P(42)$ is true therefore we can say $42 : T$. It seems that $M$ must be $U^{-1}$ but it is not a necessity. Let's say that $M$ takes an integer and returns it's binary representation. therefore $M(42) = '101010'$. The $U$ must be the opposite so $U('101010') = 42$. but what is $U('42')$, the decimal representation in a string, can we say this is undefined and domain of $U$ only accepts binary strings? This is up to the programmer that either $U = M^{-1}$ or not and programmer must define both $M$ and $U$ functions separately. At last, if we use MySQL for database server, we can say $D$ is the string <code>VARCHAR(100)</code>. This is because the result of our marshal function is a string and XUA uses that to store data in database.</div><div class = 'comment'>Now what is a Super Type? A super type is actually a function that takes some parameters and returns a type, a super type is an object a whole level above a type. Each super type eventually results in a PHP class extending a XUA abstract class called <code>XUA\Type</code>. each instance of this class is a type, and the class constructor is the function that takes some parameters and creates a type. The parameters are then accessible as attributes. For example take a look at <code>Enum</code> that takes one parameter called <code>values</code>.</div><pre><code>$genderType&nbsp;=&nbsp;new&nbsp;Enum([<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;values&#x27;&nbsp;=&gt;&nbsp;[&#x27;male&#x27;,&nbsp;&#x27;female&#x27;]<br>]);<br></code></pre><div class = 'comment'>The parameter <code>values</code> is set to array <code>[&#x27;male&#x27;, &#x27;female&#x27;]</code> and the variable <code>$genderType</code> is now a type that has the 4 discussed members.</div><div class = 'comment'>$P$, the first member, is called <code>accepts</code>.</div><pre><code>var_dump($genderType-&gt;accepts(&#x27;male&#x27;));&nbsp;\\&nbsp;dumps&nbsp;true<br></code></pre><div class = 'comment'>Since $'male' \in \{'male', 'female'\}$.</div><div class = 'comment'>$M$, the second member, is called <code>marshal</code>, and will return the index of the element in array <code>values</code>.</div><pre><code>var_dump($genderType-&gt;marshal(&#x27;male&#x27;));&nbsp;\\&nbsp;dumps&nbsp;0<br>var_dump($genderType-&gt;marshal(&#x27;female&#x27;));&nbsp;\\&nbsp;dumps&nbsp;1<br></code></pre><div class = 'comment'>$U$, the third member, is called <code>unmarshal</code>.</div><pre><code>var_dump($genderType-&gt;unmarshal(1));&nbsp;\\&nbsp;dumps&nbsp;&#x27;female&#x27;<br></code></pre><div class = 'comment'><strong>Note</strong>: The marshal and unmarshal functions of XUA's official Enum are both identity function, this is just an example.</div><div class = 'comment'>$D$, the fourth member, is called <code>databaseType</code>.</div><pre><code>var_dump($genderType-&gt;databaseType());&nbsp;\\&nbsp;dumps&nbsp;&#x27;INT&#x27;<br></code></pre><div class = 'comment'>There is also another member of this type, that gives you the parameters given to it when constructed.</div><pre><code>$genderType-&gt;parameters();<br></code></pre><div class = 'comment'>Will return the following map.</div><pre><code>[<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;value&#x27;&nbsp;=&gt;&nbsp;[&#x27;male&#x27;,&nbsp;&#x27;female&#x27;]<br>]<br></code></pre><div class = 'comment'><a href='#Entities'><h3 class='h3' id='Entities'> Entities</h3></a>
<a href='Entities.html'>(main chapter)</a></div><div class = 'comment'>XUA can be configured to communicate with a database server (usually MySQL), but the programmer needs to specify the database structure. To do so, XUA offers Entity Blocks, it will generate a PHP class extending a XUA abstract class called <code>XUA\Entity</code> for each Entity Block the programmer creates. these Entity classes are in a one-to-one relationship with database tables. Each row of the table then, can be corresponded by an instance of the tableâ€™s corresponding class.</div><div class = 'comment'>In order to define an entity, the programmer needs to define a mapping called <code>Fields</code> that contains columns of entities as keys, and their types as values. Setting the <code>Fields</code> is mandatory, but there are some optional members an entity may have. One member is a list called <code>Indices</code>, which defines the MySQL indices, that would make select queries faster, or control unique values (Read more about MySQL indices by googling). Another is the function called <code>Validation</code>, that checks if an entity instance (a row) is valid. For example assume we have two fields <code>country</code> and <code>city</code> in entity <code>User</code>, the validation function is responsible to check if the city is inside the country and avoid invalid data from storing. Therefore an entity is theoretically a triplet $E = (F, I, V)$, but you'll see that you can override entity methods, i.e., there are more to define on entity than just <code>Fields</code>, <code>Indices</code>, and <code>Validation</code>.</div><div class = 'comment'><a href='#Methods'><h3 class='h3' id='Methods'> Methods</h3></a>
<a href='Methods.html'>(main chapter)</a></div><div class = 'comment'>Methods are the main part of a XUA Project. A method is a very small unit that does a special job when called. One can think of methods as just functions but there are two differences. A method can be called from outside of the project, and can return multiple values.</div><div class = 'comment'>Methods are simply triplets $M = (Q, S, B)$. First member, <code>Request</code>, shown by $Q$, defines the structure of request that needs to be prepared and given to the method, and the second one, <code>Response</code>, shown by $S$, defines the structure of response that the method returns. The third member, <code>Body</code>, shown by $B$ is a piece of code that does all the function.</div><div class = 'comment'><a href='#PHP_Service_Classes'><h3 class='h3' id='PHP_Service_Classes'> PHP Service Classes</h3></a>
<a href='Services.html'>(main chapter)</a></div><div class = 'comment'>There are some data-types that are more than an entity or a super type. Some classes like <code>DateTime</code> are not in an equivalence relation with a database table, and are not possible to implement with XUA's super types, since the programmer may need methods like <code>addDays</code>, <code>format</code>, or <code>toJalali</code> from this data-type.</div><div class = 'comment'>Also there are some procedures that need to be implemented somewhere other than methods, for example checking if a file is an image.</div><div class = 'comment'>XUA satisfies this need by letting programmers write their own native PHP codes. Although the codes must be contained by classes, but the programmer is pretty mush free to do everything inside the classes. The XUA engine will copy these native codes to the resulting project as they are.</div><div class = 'comment'><a href='#Interfaces'><h2 class='h2' id='Interfaces'> Interfaces</h2></a>
<a href='Interfaces.html'>(main chapter)</a></div><div class = 'comment'>interfaces are where we define routes, and write the code that will execute when a user requests on a specific route, we usually avoid writing codes that include business logic, instead we just call a resource that is responsible for the route. Since we have a specific route called <a href='#Universal<em>Resources</em>Pool<em>Interface</em>(URPI)'>URPI</a> that handles all the direct requests for resources, writing a new interface is mostly useful for rendering a website, i.e., we define routes for pages the user visits, and ask a resource (a Method resource) to create an html page, and show the page created to user.</div><div class = 'comment'><a href='#Resource_Files'><h2 class='h2' id='Resource_Files'> Resource Files</h2></a>
In almost any project, there are some files that are note codes or programs, these files can be anything, assets, user uploaded files, documents, etc. In XUA's terminology, we call any non-program file, a resource file. The resource files exist directly in the resulting project directory, and the programmer must mark the directories that contain resource files as resource directory in <code>config.json</code>. Read <a href='Configurations.html'>Configurations article</a> to see how it is done.</div><div class = 'comment'><a href='#Public_Resource_Files'><h3 class='h3' id='Public_Resource_Files'> Public Resource Files</h3></a>
Resource files can be public, i.e., accessible by just going to the file's address. For example when user opens a web page in the browser, there are some assets, e.g., styles, fonts, images, etc. that browser fetches from the web server. These files must be marked as public.</div><div class = 'comment'><a href='#Private_Resource_Files'><h3 class='h3' id='Private_Resource_Files'> Private Resource Files</h3></a>
In many projects, there are some files that are needed to be on the server, but are not public files. For example think of an <em>online book store</em>. There are many <code>.pdf</code> files on the server which the server sends them by email or shows them on web only if the user is authorized and payed for the file. These files must be marked as private.</div><div class = 'comment'><a href='#XUA_Server_Generated_Units'><h2 class='h2' id='XUA_Server_Generated_Units'> XUA Server Generated Units</h2></a>
There are some units existing in the server project, that are completely generated by XUA engine and there is no need for a programmer to modify them, but it helps if the programmer knows how they work, and in some cases, the programmer may modify them in a way that is more suitable for the project.</div><div class = 'comment'><a href='#Universal_Resources_Pool_Interface_(URPI)'><h3 class='h3' id='Universal_Resources_Pool_Interface_(URPI)'> Universal Resources Pool Interface (URPI)</h3></a>
Accessing resources on same project is as easy as it was before, one unit can just call a resource internally and there is no complexity. Although accessing a resource form other machines needs a protocol, the client needs to marshal the request in a data type which is available for transmitting on the network, then we need to unmarshal the request in a way that is meaningful for Universal Resource Pool, this is done by a predefined interface called URPI. The client tells URPI what resource is needed, URPI calls the resource, prepare the result for network transmitting, and sends the result back to client, where the result can be unmarshalled and used.</div><div class = 'comment'><strong>Note:</strong> The URPI is an interface, existing in the interfaces directory of the template project. The URPI is a xua source file, meaning it is not generated when building the project, it's generated only once, when making a new project from template. Therefore this unit is modifiable and even removable.</div><div class = 'comment'><a href='#Route_Detection_Unit'><h3 class='h3' id='Route_Detection_Unit'> Route Detection Unit</h3></a>
The programmer can define <a href='#Interfaces'>interfaces</a> and set a route for each interface. When a user or client sends a request to the server, it's the job of RDU to detect which route (which interface) matches the requested URL. After the route is detected, XUA will call the interface with that specific route, and then the code inside that interface returns the desired response.</div><div class = 'comment'><strong>Note:</strong> RDU is generated each time the project is built. The modification of RDU is highly discouraged, but if one insists on, it's recommended to change it in <em>XUA code generator</em> source files, not the resulting project, since it'll get replaced with the default one each time the project is built.</div><div class = 'comment'><a href='#XUA_Exception_Handler'><h3 class='h3' id='XUA_Exception_Handler'> XUA Exception Handler</h3></a>
After the interface returned the response, it's not prepared to show to the user yet. Immediately after interface code execution, the result goes to the XEH, any uncaught exception, fatal error, warning, etc. gets caught here, and a default error page is shown to user in order to avoid inside codes and data leak, as well as making the website more user friendly.</div><div class = 'comment'>It is possible to modify the way XUA catches exceptions by modifying a special service called <code>ExceptionService</code>. For example you may want to make it possible for developers and programmers of the project to see the exact error while users must just see a simple error page. Or you may want to show an error message in json instead of showing an html page (which is already done for <a href='#Universal<em>Resources</em>Pool<em>Interface</em>(URPI)'>URPI</a>). In this cases or other similar cases, you should modify <code>ExceptionService</code> and check if the request is sent by a developer, for example by checking a special header. Read <a href='PredefinedServices.html#ExceptionService'>ExceptionService</a> for more practical information.</div><div class = 'comment'><a href='#Template_Engine'><h3 class='h3' id='Template_Engine'> Template Engine</h3></a>
The result that RDU or XEH return is an instance of class <code>XUA\Template</code>. In order to send it as a response, XUA needs to render the instance. This is done by the last unit, TE.</div><div class = 'comment'>XUA uses Twig templates with the class <code>XUA\TwigTemplate</code> by default but it's possible to override it. You just have to extend the abstract class <code>XUA\Template</code> with another template engine like <code>XUA\MyOwnTemplate</code>, and use instances of this class as return values of interfaces and XEH.</div><div class = 'comment'><a href='#Marshal_Library'><h1 class='h1' id='Marshal_Library'> Marshal Library</h1></a></div><div class = 'comment'>The <em>Marshal Library</em> is a client library can be built in several front-end languages. The library helps the front-end developers to access resources from Universal Resources Pool. For example if there is a method in the pool called <code>Method\Post\Get</code>, the front-end developer can call it using the following code in Dart.</div><pre><code>result&nbsp;=&nbsp;Marshal.Method.Post.Get(arguments);<br></code></pre><div class = 'comment'>The marshal library sends a request to the server saying we need to execute the method <code>Method\Post\Get</code>, along with marshaled <code>arguments</code>, the URPI then, unmarshals the <code>arguments</code>, calls the method, gets response, marshals it, and send it back to the client, the marshal library fetches it, unmarshals it, and returns the structured response, which then will be stored in <code>result</code>.</div><div class = 'comment'><a href='#Virtual_Resource_Pool'><h2 class='h2' id='Virtual_Resource_Pool'> Virtual Resource Pool</h2></a>
The Virtual Resource Pool is a set of methods and entities, twins of the ones in server, that just contain a server call and nothing more.</div><div class = 'comment'><a href='#Entity_Interfaces'><h3 class='h3' id='Entity_Interfaces'> Entity Interfaces</h3></a>
For each entity on the server project, a twin entity exists inside VRP, but with hollow methods. Each method only contains an HTTP request that tells the server to execute it's twin, the result is fetched from server and is returned.</div><div class = 'comment'><a href='#Method_Interfaces'><h3 class='h3' id='Method_Interfaces'> Method Interfaces</h3></a>
For each method on the server project, a twin method exists inside VRP, but with hollow body. The body only contains an HTTP request that tells the server to execute it's twin, the result is fetched from server and is returned.</div><div class = 'comment'><a href='#Local_Service_Classes'><h2 class='h2' id='Local_Service_Classes'> Local Service Classes</h2></a>
<a href='Services.html'>(main chapter)</a></div><div class = 'comment'><a href='#PHP<em>Service</em>Classes'>PHP Service Classes</a> discussed above are classes that programmers may use to instantiate objects from. These objects can be used in universal resources, for example a method may return an instance of a service class. XUA marshals the result and sends it to the <em>Marshal Library</em> where it should be unmarshalled. But how we're gonna represent the object there? Assume we have a method called <code>getNow</code>, and the method responses the variable <code>now</code>, an instance of <code>DateTimeService</code>. Then in the Dart project we want to get the Jalali representation of the <code>DateTimeService</code> using the method <code>formatJalali</code>. This is not something we ask the server to do for us. We should be able to execute the method in the client side. Therefore, if we want to use some methods of some service classes in the client-side, we should rewrite the class in native language of the client-side. The programmer is able to write native codes for the client, and the codes are copied to the <em>Marshal Library</em> when building.</div><div class = 'comment'><a href='#Marshal_Library_Generated_Units'><h2 class='h2' id='Marshal_Library_Generated_Units'> Marshal Library Generated Units</h2></a>
Just as the server project, there are some units existing in the marshal library, that are completely generated by XUA engine and there is no need for a programmer to modify them, but it helps if the programmer knows how they work, and in some cases, the programmer may modify them in a way that is more suitable for the project.</div><div class = 'comment'><a href='#Marshal/Unmarshal_Unit'><h3 class='h3' id='Marshal/Unmarshal_Unit'> Marshal/Unmarshal Unit</h3></a>
The unit that the library derived it's name from. This unit is responsible to marshal request data and unmarshal the response. The unit is affected by supers definitions, but is not directly programmable.</div><div class = 'comment'><a href='#Http_Connection_Unit'><h3 class='h3' id='Http_Connection_Unit'> Http Connection Unit</h3></a>
This is a very technical unit where requests are sent to the server, and responses are fetched. This unit is also able to modify requests and responses, for example adding user token, api key, etc. to the request. This unit is possible to modify. The programmer must modify a predefined service called <code>HttpConnectionService</code>. Read <a href='PredefinedServices.html#HttpConnectionService'>HttpConnectionService</a> for more practical information.</div><div class = 'comment'><a href='#Documentations'><h1 class='h1' id='Documentations'> Documentations</h1></a>
<a href='Documentations.html'>(main chapter)</a></div><div class = 'comment'>XUA is capable of generating a documentation for the project. Currently, the documentation is available in html and latex formats. XUA engine uses comments inside project source files to generate the docs. The current documentation that you're reading is a documentation generated by xua, and all these texts are just comments inside source files.</div><div class = 'comment'>The documentations are file-to-file, meaning that for each source file, there exists a <code>.html</code> or <code>.tex</code> file and vice versa.</div><div class = 'comment'><a href='#Service_Classes_Documentations'><h2 class='h2' id='Service_Classes_Documentations'> Service Classes Documentations</h2></a>
Service classes are the files labeled as services in <code>config.json</code>, and are only project source file without <code>.xua</code> extension. For each of these files, XUA engine generates a documentation file consisting of the comments.</div><div class = 'comment'><a href='#Super_Types_Documentations'><h2 class='h2' id='Super_Types_Documentations'> Super Types Documentations</h2></a>
Other than including the comments in the documentation, XUA can automatically generate a table of super parameters, with their types, default values, and description. The description of a parameter is the comment that comes immediately after the parameter definition, if no comment is found, the description is set to <code>-</code>. XUA can also sectionize different parts of a super, like validation, marshal, unmarshal, etc. and shows comments of each one in the related section. There are also some other minor automated functions that XUA is capable of.</div><div class = 'comment'><a href='#Entities_Documentations'><h2 class='h2' id='Entities_Documentations'> Entities Documentations</h2></a>
Other than including the comments in the documentation, XUA can automatically generate a table of entity fields, with their types, default values, description, etc. The description of a field is the comment that comes immediately after the field definition, if no comment is found, the description is set to <code>-</code>. XUA can also sectionize different parts of an entity, and some other automated functions.</div><div class = 'comment'><a href='#Entities_Graph'><h2 class='h2' id='Entities_Graph'> Entities Graph</h2></a>
Almost any project has some related entities, for example we may have an entity called <code>User</code> that has a field called <code>birthPlace</code> that comes from another Entity called <code>City</code>, and we may have another entity called <code>Restaurant</code> that has a field called <code>costumers</code> which comes from <code>User</code>, and a field called <code>city</code> that comes from <code>City</code>, and there would be many other entities with relations, these relations can be one-to-one, one-to-many, many-to-many, etc. Most of these complicated projects have a graph of entities as vertices, showing the relations by edges. XUA is capable of drawing this graph and modify it whenever an entity is modified.</div><div class = 'comment'><a href='#Methods_Documentations'><h2 class='h2' id='Methods_Documentations'> Methods Documentations</h2></a>
Other than including the comments in the documentation, XUA can automatically generate a table of request parameter, and a table of response parameters, with their types, default values, description, etc. The description of a field is the comment that comes immediately after the parameter definition, if no comment is found, the description is set to <code>-</code>. XUA can also sectionize different parts of a method, and some other automated functions.</div><div class = 'comment'><a href='#Book'><h2 class='h2' id='Book'> Book</h2></a>
Book is actually the name we call a <code>.xua</code> file, or a set of <code>.xua</code> files, when the file contains nothing, i.e., there is no super, method, or entity block. The file is empty of codes, but it can be full of comments, just like the one you're reading currently.</div><div class = 'comment'><a href='#Foreign_Units'><h1 class='h1' id='Foreign_Units'> Foreign Units</h1></a>
There are a set of units that are out of our control, they just work as they are, but they <em>are</em> important to us since we want to communicate with them.</div><div class = 'comment'><a href='#System_Resources'><h2 class='h2' id='System_Resources'> System Resources</h2></a>
System resource are usually procedures that are not written in PHP. For example chron-jobs, shell commands, Redis queues, foreign language codes, etc. But we may want to use these resources in our project. This can be done through a service.</div><div class = 'comment'>For example assume we have a code contest website, and want to compile and run some tests on uploaded codes. We may have a foreign judge project that does this for us, we just need to call it. We can write a service called <code>callJudgeService</code> and use it in a method. or if we want to manage a queue, we can write a service called <code>QueuesService</code> and call it like</div><pre><code>QueuesService::addToQueue(QueuesService::QUEUE_WAITING_TO_JUDGE_CODES,&nbsp;$uploadedCode)<br></code></pre><div class = 'comment'><a href='#Libraries'><h2 class='h2' id='Libraries'> Libraries</h2></a>
There can be some PHP libraries that we are not wishing to rewrite, for example generating a QR Code, reading an excel file, etc. We can have these codes available and write a service to call these for us. It's important to mark libraries as resource files in <code>config.json</code>, or they will be deleted when cleaning the project.</div><div class = 'comment'><a href='#3rd_Party_Apps'><h2 class='h2' id='3rd_Party_Apps'> 3rd Party Apps</h2></a>
Just similar to System Resources, and Libraries, we can write services and interfaces to communicate with 3rd Party Apps.</div><div class = 'comment'><a href='#Database_and_Cache_Servers'><h2 class='h2' id='Database_and_Cache_Servers'> Database and Cache Servers</h2></a>
One of the most important features of any server project is to communicate with a database server, entities are configured to do so. But it's also possible to configure entities to connect to a cache server instead, the cache server then communicates with the database if the data was not available.</div><div class = 'comment'><a href='#Web_Browser'><h2 class='h2' id='Web_Browser'> Web Browser</h2></a>
Web browser is the interface that user communicates with, if the project is not just a back-end project, and contains a website, then web browser is the application that communicates with the server project, which may ask for different URLs on the server that will get handled by interfaces.</div><div class = 'comment'><a href='#Native_Client_Codes'><h2 class='h2' id='Native_Client_Codes'> Native Client Codes</h2></a>
Client Codes are the codes written by front-end developers that is a user inteface for the project. These code may not communicate with the server directly, instead, the Marshal Library is called to communicate with the server.</div>

        </div>

        <div id="footer">
            This page has been generated by <a href="http://xuarazmi.ir/">xua</a>
        </div>

    </div>

</body>

</html>