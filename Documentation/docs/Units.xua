# XUA Documentation - Units
# Kamyar Mirzavaziri
# Winter 1399

# Doc Constants
    # @python doc.constants.TITLE = "Units;"
    # @python doc.constants.SUBTITLE = "The Fundamentals"

# Doc Configurations
    # @python doc.renderComments = "doc"
    # @python doc.renderCodes = "pure"

# -- #########################################
# # Introduction
# In this chapter, we try to focus on concepts and theories, reading this chapter helps the reader understand the concepts and fundamentals but to turn these theories into practice, one must read the main chapter of each section which is more practical. Not all of units are needed to be defined by the programmer and most of them are generated by XUA. There are only a few units that require practical understanding, and there is a main chapter for each.  

# -- #########################################
# # XUA Server
# XUA generates three projects. XUA Server, Marshal Library, and Documentations. Among these projects, the server is the most important
# one which contains all the units that serve logics to the whole project. The role of Server is to be an interface between user and
# database which reads and modifies data, in this manner the server must check the permissions for read and write and serve proper
# access to data for all users.

# ## Universal Resources Pool
# A XUA Server contains a pool of resources that are available for use. These resources can be available universally, i.e., foreign
# parties can use resources, and internally, i.e., available for internal resources and units. The idea is similar to private and
# public features of a class, but a public feature is only accessible from other codes on the same project, while a universal resource
# is accessible from other projects, even on other machines other than where server project is stored. XUA resources are divided to [Files](#Resource_Files), [Services](#PHP_Service_Classes), [Supers](#Super_Types), [Entities](#Entities), and [Methods](#Methods).

# ### Super Types
# [(main chapter)](Supers.html)

# Super Types or simply Supers are actually parametric types.

# Let's talk about types first. One can think of a type as a set, for example the type `Integer` is actually the set $\mathbb{Z} = \{0, 1, -1, 2, -2, \dots \}$ and when we say that $42$ is of type `Integer`, this means that $42 \in \mathbb{Z}$, which is written $42 : \mathbb{Z}$ in XUA syntax. But there are some features that types usually have which sets don't. In XUA's definition of type, types have a characteristic function which defines the set, and also a marshal function and an unmarshal function that prepare the values for transmitting or storing. There is also another property for types, called `DatabaseType` which tells the database how to store a value of this type. So a type is actually a 4-tuple $T = (P, M, U, D)$ where predicate $P$ is the characteristic function, $M$ is the marshal function, $U$ is the unmarshal function, and $D$ is a string that defines the database type.

# As an example (that is not quite practical and efficient) let $T$ be the type of integers. We know $P(42)$ is true therefore we can say $42 : T$. It seems that $M$ must be $U^{-1}$ but it is not a necessity. Let's say that $M$ takes an integer and returns it's binary representation. therefore $M(42) = '101010'$. The $U$ must be the opposite so $U('101010') = 42$. but what is $U('42')$, the decimal representation in a string, can we say this is undefined and domain of $U$ only accepts binary strings? This is up to the programmer that either $U = M^{-1}$ or not and programmer must define both $M$ and $U$ functions separately. At last, if we use MySQL for database server, we can say $D$ is the string `VARCHAR(100)`. This is because the result of our marshal function is a string and XUA uses that to store data in database.  

# Now what is a Super Type? A super type is actually a function that takes some parameters and returns a type, a super type is an object a whole level above a type. Each super type eventually results in a PHP class extending a XUA abstract class called `XUA\Type`. each instance of this class is a type, and the class constructor is the function that takes some parameters and creates a type. The parameters are then accessible as attributes. For example take a look at `Enum` that takes one parameter called `values`.
#    $genderType = new Enum([
#        'values' => ['male', 'female']
#    ]);

# The parameter `values` is set to array `['male', 'female']` and the variable `$genderType` is now a type that has the 4 discussed members.

# $P$, the first member, is called `accepts`.
#    var_dump($genderType->accepts('male')); \\ dumps true
# Since $'male' \in \{'male', 'female'\}$.

# $M$, the second member, is called `marshal`, and will return the index of the element in array `values`.
#    var_dump($genderType->marshal('male')); \\ dumps 0
#    var_dump($genderType->marshal('female')); \\ dumps 1

# $U$, the third member, is called `unmarshal`.
#    var_dump($genderType->unmarshal(1)); \\ dumps 'female'
# __Note__: The marshal and unmarshal functions of XUA's official Enum are both identity function, this is just an example.

# $D$, the fourth member, is called `databaseType`.
#    var_dump($genderType->databaseType()); \\ dumps 'INT'

# There is also another member of this type, that gives you the parameters given to it when constructed.
#    $genderType->parameters();
# Will return the following map.
#    [
#        'value' => ['male', 'female']
#    ]

# ### Entities
# [(main chapter)](Entities.html)

# XUA can be configured to communicate with a database server (usually MySQL), but the programmer needs to specify the database structure. To do so, XUA offers Entity Blocks, it will generate a PHP class extending a XUA abstract class called `XUA\Entity` for each Entity Block the programmer creates. these Entity classes are in a one-to-one relationship with database tables. Each row of the table then, can be corresponded by an instance of the tableâ€™s corresponding class.

# In order to define an entity, the programmer needs to define a mapping called `Fields` that contains columns of entities as keys, and their types as values. Setting the `Fields` is mandatory, but there are some optional members an entity may have. One member is a list called `Indices`, which defines the MySQL indices, that would make select queries faster, or control unique values (Read more about MySQL indices by googling). Another is the function called `Validation`, that checks if an entity instance (a row) is valid. For example assume we have two fields `country` and `city` in entity `User`, the validation function is responsible to check if the city is inside the country and avoid invalid data from storing. Therefore an entity is theoretically a triplet $E = (F, I, V)$, but you'll see that you can override entity methods, i.e., there are more to define on entity than just `Fields`, `Indices`, and `Validation`.  

# ### Methods
# [(main chapter)](Methods.html)

# Methods are the main part of a XUA Project. A method is a very small unit that does a special job when called. One can think of methods as just functions but there are two differences. A method can be called from outside of the project, and can return multiple values.

# Methods are simply triplets $M = (Q, S, B)$. First member, `Request`, shown by $Q$, defines the structure of request that needs to be prepared and given to the method, and the second one, `Response`, shown by $S$, defines the structure of response that the method returns. The third member, `Body`, shown by $B$ is a piece of code that does all the function.

# ### PHP Service Classes
# [(main chapter)](Services.html)

# There are some data-types that are more than an entity or a super type. Some classes like `DateTime` are not in an equivalence relation with a database table, and are not possible to implement with XUA's super types, since the programmer may need methods like `addDays`, `format`, or `toJalali` from this data-type.

# Also there are some procedures that need to be implemented somewhere other than methods, for example checking if a file is an image.

# XUA satisfies this need by letting programmers write their own native PHP codes. Although the codes must be contained by classes, but the programmer is pretty mush free to do everything inside the classes. The xua engine will copy these native codes to the resulting project as they are.

# ## Interfaces
# [(main chapter)](Interfaces.html)

# interfaces are where we define routes, and write the code that will execute when a user requests on a specific route, we usually avoid writing codes that include business logic, instead we just call a resource that is responsible for the route. Since we have a specific route called [URPI](#Universal_Resources_Pool_Interface_\(URPI\)) that handles all the direct requests for resources, writing a new interface is mostly useful for rendering a website, i.e., we define routes for pages the user visits, and ask a resource (a Method resource) to create an html page, and show the page created to user.

# ## Resource Files

# In almost any project, there are some files that are note codes or programs, these files can be anything, assets, user uploaded files, documents, etc. In XUA's terminology, we call any non-program file, a resource. The resources exist directly in the resulting project directory, and the programmer must mark the directories that contain resources as resource directory in config.json. Read [Configurations article](Configurations.html) to see how it is done.

# ### Public Resource Files

# Resource files can be public, i.e., accessible by just going to the file's address. For example when user opens a web page in the browser, there are some assets, e.g., styles, fonts, images, etc. that browser fetches from the web server. These files must be marked as public.

# ### Private Resource Files

# In many projects, there are some files that are needed to be on the server, but are not public files. For example think of an _online book store_. There are many `.pdf` files on the server which the server sends them by email or shows them on web only if the user is authorized and payed for the file. These files must be marked as private.

# ## XUA Server Generated Units

# There are some units existing in the server project, that are completely generated by XUA engine and there is no need for a programmer to modify them, but it helps if the programmer knows how they work, and in some cases, the programmer may modify them in a way that is more suitable for the project.

# ### Universal Resources Pool Interface (URPI)

# Accessing resources on same project is as easy as it was before, one unit can just call a resource internally and there is no complexity. Although accessing a resource form other machines needs a protocol, the client needs to marshal the request in a data type which is available for transmitting on the network, then we need to unmarshal the request in a way that is meaningful for Universal Resource Pool, this is done by a predefined interface called URPI. The client tells URPI what resource is needed, URPI calls the resource, prepare the result for network transmitting, and sends the result back to client, where the result can be unmarshaled and used.

# __Note:__ The URPI is an interface, existing in the interfaces directory of the template project. The URPI is a xua source file, meaning it is not generated when building the project, it's generated only once, when making a new project from template. Therefore this unit is modifiable and even removable.


# ### Route Detection Unit

# ### XUA Exception Handler

# ### Template Engine

# -- #########################################
# # Marshal Library

# ## Local Service Classes

# ## Virtual Resource Pool

# ### Entity Interfaces

# ### Method Interfaces

# ## Marshal Library Generated Units

# ### Marshal/Unmarshal Unit

# ### Http Connection Unit

# -- #########################################
# # Documentations

# ## Service Classes Documentations

# ## Super Types Documentations

# ## Entities Documentations

# ## Entities Graph

# ## Methods Documentations

# ## Book

# -- #########################################
# # Foreign Units

# ## System Resources

# ## Libraries

# ## 3rd Party Apps

# ## Database and Cache Servers

# ## Web Browser

# ## Native Client Codes



